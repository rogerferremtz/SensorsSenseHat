// SPDX-License-Identifier: GPL-2.0 WITH Linux-syscall-note
/**
 * Program @file RTIMULibDrive10.cpp
 * Version   1.3
 *
 * @brief Programa de posicionament i resposta luminica a canvi de posició del dispositiu
 *
 * @author Roger Ferré Martínez
 * @author Xorxe Oural Martínez
 * 
 * Copyright (C) 2020
 *
 * License GNU/GPL, see COPYING
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses/.
 *
 */

#include "RTIMULib.h"

int main()
{
    int sampleCount = 0;
    int sampleRate = 0;
    uint64_t rateTimer;
    uint64_t displayTimer;
    uint64_t now;

/**Fa servir l'arxiu .ini amb les preferències establertes en ell*/

    

    RTIMUSettings *settings = new RTIMUSettings("RTIMULib");  //  using RTIMULib here allows it to use the .ini file generated by RTIMULibDemo.

    RTIMU *imu = RTIMU::createIMU(settings);
    RTPressure *pressure = RTPressure::createPressure(settings);

    if ((imu == NULL) || (imu->IMUType() == RTIMU_TYPE_NULL)) {
        printf("No IMU found\n");
        exit(1);
    }

    //  set up IMU

    imu->IMUInit();

/**Espai de configuració dels paràmetres*/
  

    imu->setSlerpPower(0.02);
    imu->setGyroEnable(true);
    imu->setAccelEnable(true);
    imu->setCompassEnable(true);

/**Es defineix el comptador*/

    rateTimer = displayTimer = RTMath::currentUSecsSinceEpoch();

/**Bucle de processament de les dades*/

    while (1) {
        //  poll at the rate recommended by the IMU

        usleep(imu->IMUGetPollInterval() * 1000);

        while (imu->IMURead()) {
            RTIMU_DATA imuData = imu->getIMUData();

            sampleCount++;

            now = RTMath::currentUSecsSinceEpoch();

            //  display 10 times per second

            if ((now - displayTimer) > 100000) {               
                printf("Inclination in the three axis: %s\n", RTMath::displayDegrees("", imuData.fusionPose));  // Mostra l'angle d'inclinació.

                fflush(stdout);
                displayTimer = now;
            }

/**Actualització de les dades cada segon*/

            if ((now - rateTimer) > 1000000) {
                sampleRate = sampleCount;
                sampleCount = 0;
                rateTimer = now;
            }
        }
    }
}

